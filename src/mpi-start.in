#!/bin/bash
#
# Copyright (c) 2006-2007 High Performance Computing Center Stuttgart,
#                         University of Stuttgart.  All rights reserved.
# Copyright (c) 2009-2010 Instituto de Fisica de Cantabria, 
#                         CSIC-UC. All rights reserved.
#
#
# Return values of this script:
# 0   - Success

if test "x$I2G_MPI_START_FULL_TRACE" = "x1"  ; then
    set -x
fi

# initialize internal variables
MPI_START_MACHINEFILE=""
MPI_START_HOSTFILE=""
MPI_START_HOST_SLOTS_FILE=""
MPI_START_NHOSTS=0
MPI_START_NSLOTS=0
MPI_START_NSLOTS_PER_HOST=0
MPI_START_READY=-1 
MPI_START_MPI_PREFIX=""
MPI_START_CLEANUP_FILES=""
MPI_START_SCHEDULER=""
MPI_START_NP=1
MPI_START_DUMMY_SCHEDULER=${MPI_START_DUMMY_SCHEDULER:-1}


#======================================================================
# Cleans up temporary files upon finishing execution 
#======================================================================
clean_up () {
    if test "x$I2G_MPI_START_KEEP_FILES" != "x1"; then
        exit
    fi
    debug_msg "Cleaning up mpi-start temporary files."
    for file in $MPI_START_CLEANUP_FILES; do
        [ -f $file ] && rm -f $file
    done
    exit
}

trap clean_up EXIT

#======================================================================
# Displays a warning message
#======================================================================
warn_msg () {
    #if test "x$I2G_MPI_START_VERBOSE" = "x1" ; then 
    echo "mpi-start [WARNING]:" "$@" 1>&2
    #fi
}

#======================================================================
# Displays a warning message
#======================================================================
error_msg () {
    echo "mpi-start [ERROR  ]:" "$@" 1>&2
}

#======================================================================
# Display a debug message in the case that I2G_MPI_START_DEBUG
# is 1.
#======================================================================
debug_msg () {
    if test "x$I2G_MPI_START_VERBOSE" = "x1" ; then 
        if test "x$I2G_MPI_START_DEBUG" = "x1"  ; then
            echo "mpi-start [DEBUG  ]: $@" 1>&2
        fi
    fi
}

#======================================================================
# Display a debug message in the case that I2G_MPI_START_DEBUG
# is 1.
#======================================================================
info_msg () {
    if test "x$I2G_MPI_START_VERBOSE" = "x1" ; then 
        echo "mpi-start [INFO   ]: $@" 1>&2
    fi
}

#======================================================================
# Dump environment.
# $1 level
#======================================================================
dump_env () {
    if test "x$I2G_MPI_START_TRACE" = "x1"  ; then
        set +x
    fi
    if test "x$I2G_MPI_START_VERBOSE" = "x1" ; then 
        for i in `env`; do
            echo "mpi-start [DUMPENV]:" $i 1>&2
        done
    fi
}

#======================================================================
# Find the correct parameter for the mktemp program.
#======================================================================
mpi_start_find_mktemp () {
    MPI_START_MKTEMP=mktemp
    tempfile=`$MPI_START_MKTEMP 2> /dev/null`
    if test $? -ne 0 ; then
        # BSD style mktemp
        MPI_START_MKTEMP="mktemp -t MPI_START"
        tempfile=`$MPI_START_MKTEMP 2> /dev/null`
        if test $? -ne 0 ; then
            error_msg "Could not find a proper mktemp utility"
            dump_env
            exit 1
        fi
    fi
    rm -f $tempfile
}

#======================================================================
# mpi-start mktemp 
#======================================================================
mpi_start_mktemp () {
    MPI_START_TEMP_FILE=`$MPI_START_MKTEMP $*`
    MPI_START_CLEANUP_FILES="$MPI_START_TEMP_FILE $MPI_START_CLEANUP_FILES"
}

#======================================================================
# Activate a MPI by the given information. If there are module
# informations available then the modules system will be used
# otherwise the PATH and LD_LIBRARY_PATH is updated manually.
#
# $1 the MPI prefix path (mandatory)
# $2 the MPI module string (optional)
#======================================================================
mpi_start_activate_mpi () {
    if test "x$2" = "x" ; then
        debug_msg "activate MPI via manually update"
        if test -d "$1" ; then
            export PATH=$1/bin:$PATH
            export LD_LIBRARY_PATH=$1/lib:$LD_LIBRARY_PATH
        fi
    else
        debug_msg "activate MPI via modules : $2"
        for mod in $2 ; do
            debug_msg  "+  module load  $mod"
            module load $mod
        done
    fi
}

#======================================================================
# Create the wrapper that will contain the mpirun call
# It is executed as a child of mpistart in order to allow different
# env variables
#======================================================================
mpi_start_create_wrapper() {
    if test "x${MPI_START_MPI_WRAPPER}" = "x" ; then
        mpi_start_mktemp
        export MPI_START_MPI_WRAPPER=$MPI_START_TEMP_FILE
        cat > $MPI_START_MPI_WRAPPER << EOF
#!/bin/sh
test "x\$I2G_MPI_START_TRACE" = "x1" && set -x
EOF
    fi
}

#======================================================================
# Export a variable for the MPI job. It will be defined only in the
# context of the job (executed in a different process)
#
# $1 the name of the variable
# rest of parameters: variable value 
#======================================================================
mpi_start_export_variable () {
    mpi_start_create_wrapper
    var_name=$1
    shift
    if test "x$*" != "x"; then  
        echo "export $var_name=\"$*\"" >> $MPI_START_MPI_WRAPPER
    else
        echo "export $var_name" >> $MPI_START_MPI_WRAPPER
    fi
    export MPI_START_ENV_VARIABLES="$MPI_START_ENV_VARIABLES $var_name"
}

#======================================================================
# Execute the MPI command line in the wrapper
#
# $* command line to execute 
#======================================================================
mpi_start_execute_wrapper() {
    if test "x${MPI_START_DO_NOT_USE_WRAPPER}" = "x1" ; then
        if test "x${I2G_MPI_APPLICATION_STDIN}" = "x" ; then
            # no input
            if test "x${I2G_MPI_APPLICATION_STDOUT}" = "x" ; then
                # no output
                if test "x${I2G_MPI_APPLICATION_STDERR}" = "x" ; then
                    # no error
                    $*
                else
                    # only error
                    $* 2> ${I2G_MPI_APPLICATION_STDERR}
                fi
            else
                if test "x${I2G_MPI_APPLICATION_STDERR}" = "x" ; then
                    # only output
                    $* \> ${I2G_MPI_APPLICATION_STDOUT}
                elif test ${I2G_MPI_APPLICATION_STDOUT} = ${I2G_MPI_APPLICATION_STDERR} ; then
                    # same output and error
                    $* \> ${I2G_MPI_APPLICATION_STDOUT} 2>&1
                else
                    # different output and error
                    $* \> ${I2G_MPI_APPLICATION_STDOUT} 2> ${I2G_MPI_APPLICATION_STDERR} 
                fi
            fi
        else
            if test "x${I2G_MPI_APPLICATION_STDOUT}" = "x" ; then
                # no output
                if test "x${I2G_MPI_APPLICATION_STDERR}" = "x" ; then
                    # no error
                    $* < $I2G_MPI_APPLICATION_STDIN
                else
                    # only error
                    $* 2> ${I2G_MPI_APPLICATION_STDERR} < $I2G_MPI_APPLICATION_STDIN
                fi
            else
                if test "x${I2G_MPI_APPLICATION_STDERR}" = "x" ; then
                    # only output
                    $* \> ${I2G_MPI_APPLICATION_STDOUT} < $I2G_MPI_APPLICATION_STDIN
                elif test ${I2G_MPI_APPLICATION_STDOUT} = ${I2G_MPI_APPLICATION_STDERR} ; then
                    # same output and error
                    $* \> ${I2G_MPI_APPLICATION_STDOUT} 2>&1 < $I2G_MPI_APPLICATION_STDIN
                else
                    # different output and error
                    $* \> ${I2G_MPI_APPLICATION_STDOUT} 2> ${I2G_MPI_APPLICATION_STDERR} < $I2G_MPI_APPLICATION_STDIN
                fi
            fi
        fi
        return $?
    else
        mpi_start_create_wrapper
        # we create a new wrapper for each execution so we can have more than
        # one MPI execution in a single mpi-start call (not sure if it has any use)
        mpi_start_mktemp
        export CMD_WRAPPER=$MPI_START_TEMP_FILE
        chmod +x $CMD_WRAPPER
        cat $MPI_START_MPI_WRAPPER > $CMD_WRAPPER
        OUTPUT=""
        ERROR=""
        INPUT=""
        if test "x${I2G_MPI_APPLICATION_STDOUT}" != "x" ; then
            OUTPUT="> ${I2G_MPI_APPLICATION_STDOUT}"
        fi
        if test "x${I2G_MPI_APPLICATION_STDERR}" != "x" ; then
            if test "x${I2G_MPI_APPLICATION_STDOUT}" = "x${I2G_MPI_APPLICATION_STDERR}" ; then
                ERROR="2>&1"
            else
                ERROR="2> ${I2G_MPI_APPLICATION_STDERR}"
            fi
        fi
        if test "x${I2G_MPI_APPLICATION_STDIN}" != "x" ; then
            INPUT="< ${I2G_MPI_APPLICATION_STDIN}"
        fi 
        echo "$* $OUTPUT $ERROR $INPUT" >> $CMD_WRAPPER
        echo "exit \$?" >> $CMD_WRAPPER
        $CMD_WRAPPER
        err=$?
        rm -f $CMD_WRAPPER
        return $err
    fi
}

#======================================================================
# Create dummy scheduler environment with just the current host 
#======================================================================
dummy_scheduler() {
    info_msg "no scheduler found, using dummy environment with localhost"
    mpi_start_mktemp
    export MPI_START_MACHINEFILE=$MPI_START_TEMP_FILE
    mpi_start_mktemp
    export MPI_START_HOSTFILE=$MPI_START_TEMP_FILE
    mpi_start_mktemp
    export MPI_START_HOST_SLOTS_FILE=$MPI_START_TEMP_FILE
    myhost=`hostname`
    slots=1
    if test "x${MPI_DUMMY_SCH_SLOTS}" != "x" ; then
        slots=$MPI_DUMMY_SCH_SLOTS
    fi
    n=$slots
    while [ $n -ne 0 ]; do
        echo $myhost >> $MPI_START_MACHINEFILE
        n=`expr $n - 1`
    done
    echo $myhost > $MPI_START_HOSTFILE
    echo "$myhost $slots"> $MPI_START_HOST_SLOTS_FILE
    export MPI_START_NSLOTS=$slots
    export MPI_START_NHOSTS=1
    export MPI_START_NSLOTS_PER_HOST=$slots
    SCHEDULER_NAME="mpi-start-dummy"
    export MPI_START_SCHEDULER=$SCHEDULER_NAME
}


#======================================================================
# Checks that mpi-start are correct and coherent
#======================================================================
check_options() {
    # debug me 
    if test "x$I2G_MPI_START_DEBUG" = "x1" ; then 
        debug_msg "dump configuration"
        for var in I2G_MPI_APPLICATION I2G_MPI_APPLICATION_ARGS I2G_MPI_TYPE \
                   I2G_MPI_VERSION I2G_MPI_PRE_RUN_HOOK I2G_MPI_POST_RUN_HOOK \
                   I2G_MPI_PRECOMMAND I2G_MPI_FLAVOUR I2G_MPI_JOB_NUMBER \
                   I2G_MPI_STARTUP_INFO I2G_MPI_RELAY \
                   I2G_MPI_PER_NODE I2G_MPI_PER_CORE I2G_MPI_PER_SOCKET \
                   I2G_MPI_APPLICATION_STDIN I2G_MPI_APPLICATION_STDOUT I2G_MPI_APPLICATION_STDERR \
                   I2G_MPI_NP I2G_MPI_SINGLE_PROCESS I2G_MPI_CONFIG; 
        do
            eval value="\${$var}"
            debug_msg "=> ${var}=${value}"
        done
    fi

    # trace me
    if test "x$I2G_MPI_START_TRACE" = "x1"  ; then
        debug_msg "enable full trace debugging"
        set -x
    fi

    MPI_START_UNAME=`uname -s | tr "[:upper:]" "[:lower:]"`

    if test -r "${I2G_MPI_CONFIG}" ; then 
        . ${I2G_MPI_CONFIG}
        if test $? -ne 0 ; then
            error_msg "Failed to load configuration file $I2G_MPI_CONFIG"
            dump_env
            exit 2
        fi
    fi
    
    if test "x${I2G_MPI_SINGLE_PROCESS}" = "x1" ; then
        if test "x${I2G_MPI_PER_NODE}" != "x" ; then
            warn_msg "Process per node option ($I2G_MPI_PER_NODE) overriding single process option!"
        else
            export I2G_MPI_PER_NODE=1
        fi
    fi

    if test "x${I2G_MPI_PER_NODE}" != "x" ; then
        if test "x${I2G_MPI_PER_SOCKET}${I2G_MPI_PER_CORE}" != "x" ; then
            warn_msg "node option used together with core or socket! only node specification will be considered"
            unset I2G_MPI_PER_CORE
            unset I2G_MPI_PER_SOCKET
        fi
    elif test "x${I2G_MPI_PER_CORE}" != "x" -a  "x${I2G_MPI_PER_SOCKET}" != "x" ; then
        warn_msg "core option used together with socket! only socket specification will be considered"
        unset I2G_MPI_PER_CORE
    fi

    if test "x${I2G_MPI_PER_NODE}${I2G_MPI_PER_SOCKET}${I2G_MPI_PER_CORE}" != "x" \
            -a "x${I2G_MPI_NP}" != "x" ; then
        warn_msg "Total number of processes (np) option overriden by node/socket/core option!"
        unset I2G_MPI_NP
    fi

    # check for correct mktemp
    mpi_start_find_mktemp

    # set global internal variables 
    MPI_START_PREFIX=`dirname $I2G_MPI_START`
    # TODO! allow several configuration directories/files
    MPI_START_ETC="$MPI_START_PREFIX/../etc/mpi-start"
    if test ! -d "$MPI_START_ETC" ; then
        MPI_START_ETC="/etc/mpi-start"
        if test ! -d "$MPI_START_ETC" ; then
            MPI_START_ETC="$MPI_START_PREFIX/../share/mpi-start"
            if test ! -d "$MPI_START_ETC" ; then
                error_msg "unable to find mpi-start modules"
                dump_env
                exit 2
            fi
        fi
    fi
}

mpi_start_scheduler_detector() {
    # check for scheduling system and set environment variables
    info_msg "search for scheduler"
    for i in $MPI_START_ETC/*.scheduler  ; do 
        # source the function definitions
        unset scheduler
        unset scheduler_available
        unset scheduler_get_machinefile
        debug_msg "source $i"
        . $i
        if test $? -ne 0  ; then 
            warn_msg "failed to source : $i"
        fi

        scheduler=`basename $i .scheduler`

        # check if support for this kind of schedulers is supported
        debug_msg "checking for scheduler support : $scheduler"
        scheduler_available
        result=$?

        if test "x$result" = "x0" ; then 
            info_msg "activate support for $scheduler"

            # support for this scheduler is found.
            # So lets setup the internal environment.
            scheduler_get_machinefile
            result=$?

            if test $result -ne 0 ; then
                error_msg "cannot create machine file"
                dump_env
                exit 2
            fi

            # mark MPI_START as ready to go 
            MPI_START_READY=0
            export MPI_START_SCHEDULER=$SCHEDULER_NAME
            break
        fi
    done

    # check if we have a scheduler 
    if test $MPI_START_READY -ne 0  ; then 
        if test "x${MPI_START_DUMMY_SCHEDULER}" == "x1" ; then
            dummy_scheduler
        else
            error_msg "cannot find scheduler"
            dump_env
            exit 3 
        fi
    fi
}

mpi_start_linux_core_detector() {
    MPI_START_SOCKETS=`cat /proc/cpuinfo | grep "physical id" | sort -u | wc -l`
    if test $? -ne 0 ; then
        warn_msg "Unable to detect number of cpus, assuming 1"
        MPI_START_SOCKETS=1
    fi
    MPI_START_COREPERSOCKET=`cat /proc/cpuinfo | grep "cpu cores" | sort -u | cut -f2 -d":" | tr -d " "`
    if test $? -ne 0 ; then
        warn_msg "Unable to detect number of cores per cpu, assuming 1"
        MPI_START_COREPERSOCKET=1
    fi
}

mpi_start_darwin_core_detector() {
    MPI_START_COREPERSOCKET=`sysctl -n machdep.cpu.cores_per_package`
    if echo $MPI_START_COREPERSOCKET | grep "^machdep:" > /dev/null ; then
        warn_msg "Unable to detect number of cores per cpu, assuming 1"
        MPI_START_COREPERSOCKET=1
    fi
    TOTALCPUS=`sysctl -n hw.ncpu`
    if test $? -ne 0 ; then
        warn_msg "Unable to detect total number of cpus, assuming 1"
        MPI_START_SOCKETS=1
    else
        MPI_START_SOCKETS=`expr $TOTALCPUS / $MPI_START_COREPERSOCKET`
    fi  
}

mpi_start_core_detector() {
    debug_msg "Detection of core/cpu topology."

    MPI_START_SOCKETS=1
    MPI_START_COREPERSOCKET=1
    if test "x${MPI_START_UNAME}" = "xlinux" ; then
        mpi_start_linux_core_detector
    elif test "x${MPI_START_UNAME}" = "xdarwin" ; then
        mpi_start_darwin_core_detector
    else
        info_msg "Physical layout of CPU not implemented for your OS ($MPI_START_UNAME)"
    fi
    info_msg "Detected $MPI_START_SOCKETS CPU socket(s) and $MPI_START_COREPERSOCKET core(s) per CPU"
}

#======================================================================
# The main function that binds everything together
#======================================================================
main() {
    #
    # Output general information
    #
    info_msg "************************************************************************" 
    info_msg "UID     = " `whoami` 
    info_msg "HOST    = " `hostname` 
    info_msg "DATE    = " `date`
    info_msg "VERSION =  @VERSION@"  
    info_msg "************************************************************************"

    debug_msg "Command line arguments: $*" 

    check_options
    
    mpi_start_scheduler_detector

    # core/cpu detection
    mpi_start_core_detector

    debug_msg "dump hosts:"
    for i in `cat $MPI_START_HOSTFILE` ; do
        debug_msg "=> $i"
    done

    if test "x${I2G_MPI_PER_NODE}" != "x" ; then
        export MPI_START_NP=`expr $MPI_START_NHOSTS '*' $I2G_MPI_PER_NODE`
    elif test "x${I2G_MPI_PER_SOCKET}${I2G_MPI_PER_CORE}" != "x" ; then
        warn_msg "*************************************************************"
        warn_msg " MPI-Start will assume all hosts have same number of sockets "
        warn_msg " and that whole hosts are allocated for the job "
        warn_msg "*************************************************************"
        if test "x${I2G_MPI_PER_SOCKET}" != "x" ; then
            export MPI_START_NP=`expr $MPI_START_NHOSTS '*' $MPI_START_SOCKETS`
        else
            export MPI_START_NP=`expr $MPI_START_NHOSTS '*' $MPI_START_SOCKETS '*' $MPI_START_COREPERSOCKET`
        fi
    elif test "x${I2G_MPI_NP}" != "x" ; then
        export MPI_START_NP=$I2G_MPI_NP
    else
        export MPI_START_NP=$MPI_START_NSLOTS
    fi

    # setup the np count 
    debug_msg "starting with $MPI_START_NP processes."


    debug_msg "check for site environment"

    # check if we should should use default MPI falvour
    if test "x$I2G_MPI_TYPE" = "x"  ; then 
        debug_msg " check for site default MPI flavour"
        if test "x$MPI_DEFAULT_FLAVOUR" != "x"  ; then
            debug_msg "   using default MPI flavour : $MPI_DEFAULT_FLAVOUR"
            export I2G_MPI_TYPE=$MPI_DEFAULT_FLAVOUR
        else
            debug_msg " no MPI flavour specified, using generic."
            export I2G_MPI_TYPE="generic"
        fi
    else
        debug_msg " using user requested MPI flavour"
    fi 

    # load the mpi plugin
    MPI_PLUGIN_FILE=$MPI_START_ETC/$I2G_MPI_TYPE.mpi
    if test ! -e $MPI_PLUGIN_FILE  ; then 
        error_msg "failed to find requested MPI type : $I2G_MPI_TYPE"
        dump_env 
        exit 2
    fi

    MPI_TYPE=`echo $I2G_MPI_TYPE | tr "[:lower:]" "[:upper:]" | tr "-" "_"`
    US=_
    MPI_PREFIX="MPI_"
    MPI_PATH_SUFFIX="_PATH"
    MPI_MODULE_SUFFIX="_MODULES"
    MPI_VERSION_SUFFIX="_VERSION"

    MPI_VERSION=
    if test "x$I2G_MPI_VERSION" != "x" ; then
        debug_msg " user requested MPI version : $I2G_MPI_VERSION"
        MPI_VERSION=$I2G_MPI_VERSION
    else
        MPI_VERSION=`eval echo \\$${MPI_PREFIX}${MPI_TYPE}${MPI_VERSION_SUFFIX}`
    fi

    if test "x{$MPI_VERSION}" != "x" ; then
        debug_msg " will check for specific MPI version : $MPI_VERSION"
        MPI_VERSION=`echo $MPI_VERSION | sed -e s/\\\\./__/g`
    fi

    # FIXME: why there is I2G_<flavour>_PREFIX and MPI_<flavour>_PATH ?
    #        will keep both to keep compatibility, but one of them should
    #        be removed
    #        I2G_<flavour>_PREFIX takes precedence over the others
    #        then MPI_<flavour>_<version>_PATH and last
    #        MPI_<flavour>_PATH
    I2G_PREFIX=`eval echo \\$I2G_${MPI_TYPE}_PREFIX`
    if test "x$I2G_PREFIX" = "x" ; then
        # first check the one with version included
        VALUE=`eval echo \\$${MPI_PREFIX}${MPI_TYPE}${US}${MPI_VERSION}${MPI_PATH_SUFFIX}`
        if test "x$VALUE" != "x" ; then
            debug_msg " found MPI version: $MPI_VERSION"
            MPI_START_MPI_PREFIX=$VALUE
        else
            # try default without version
            VALUE=`eval echo \\$${MPI_PREFIX}${MPI_TYPE}${MPI_PATH_SUFFIX}`
            if test "x$VALUE" != "x"  ; then 
                debug_msg " found default MPI in: $VALUE"
                MPI_START_MPI_PREFIX=$VALUE
            else
                #debug_msg " coulnd't find EGEE environment"
                MPI_START_MPI_PREFIX=
            fi
        fi
    else
        debug_msg "use user provided prefix : $I2G_PREFIX"
        MPI_START_MPI_PREFIX=$I2G_PREFIX
    fi
    export MPI_START_MPI_PREFIX
    
    # source the MPI specific configuration file
    info_msg "activate support for $I2G_MPI_TYPE"
    debug_msg "source : $MPI_PLUGIN_FILE"
    . $MPI_PLUGIN_FILE
    if test $? -ne 0 ; then
        error_msg "Error loading the MPI plugin: $MPI_PLUGIN_FILE"
        dump_env
        exit 1
    fi

    # export X509_USER_PROXY if it's there.
    if test "x$X509_USER_PROXY" != "x" ; then
        mpi_start_export_variable X509_USER_PROXY
    fi

    # call the MPI specific startup functions
    info_msg "call backend MPI implementation"
    mpi_start
    result=$?

    exit $result
}


#======================================================================
#  Print command line usage.
#======================================================================
print_usage () {
    echo "mpi-start [-h] [-t mpi_type] [-v] [-vv] [-vvv]" 1>&2
    echo "    [-pre hook] [-post hook] [-pcmd cmd]" 1>&2
    echo "    [-npnode n] [-np n]" 1>&2
    echo "    [-pcore] [-psocket] [-pnode]" 1>&2
    echo "    [-i file] [-o file] [-e file]" 1>&2
    echo "    [-x VAR[=VALUE]] [-d VAR=VALUE] [--]" 1>&2
    echo "    application [...]" 1>&2
    echo  1>&2
    echo "Parallel job starter" 1>&2
    echo  1>&2
    echo "optional arguments:" 1>&2
    echo "  -h             show this help message and exit" 1>&2
    echo "  -V             show mpi-start version" 1>&2
    echo "  -t type        use the mpi type (sets I2G_MPI_TYPE)" 1>&2
    echo "  -v             verbose" 1>&2
    echo "  -vv            debug" 1>&2
    echo "  -vvv           full trace" 1>&2
    echo "  -pre hook      use specified pre run hook script" 1>&2
    echo "  -post hook     use specified post run hook script" 1>&2
    echo "  -pcmd cmd      use specified pre command" 1>&2
    echo "  -npnode n      set number of processes per node" 1>&2
    echo "  -pcore         start only one process per core" 1>&2
    echo "  -psocket       start only one process per cpu socket" 1>&2
    echo "  -pnode         start only one process per node" 1>&2
    echo "  -np n          set total number of processes" 1>&2
    echo "  -c file        use file for sourcing mpi-start variables" 1>&2
    echo "  -i file        use file for standard input" 1>&2
    echo "  -o file        use file for standard output" 1>&2
    echo "  -e file        use file for standard error" 1>&2
    echo "  -x VAR[=VALUE] export the environment variable VAR," 1>&2
    echo "                   optionally define value" 1>&2
    echo "  -d VAR=VALUE   define mpi-start variable VAR with specified VALUE" 1>&2
    echo "  --             separator for application and arguments" 1>&2
}

print_version () {
    echo "mpi-start v@VERSION@" 
}

if test "$I2G_MPI_START_ENABLE_TESTING" != "TEST" ; then
    #======================================================================
    #  Parse the command line arguments and call the main function 
    #======================================================================
    export I2G_MPI_START=$0
    arguments="$*"
    while [ "x$1" != "x" ] ; do
        case "$1" in 
            -h)
                print_usage
                exit 0
                ;;
            -V)
                print_version
                exit 0
                ;;
            -t)
                shift
                export I2G_MPI_TYPE=$1
                shift
                ;;
            -v)
                export I2G_MPI_START_VERBOSE=1
                shift
                ;;
            -vv)
                export I2G_MPI_START_VERBOSE=1
                export I2G_MPI_START_DEBUG=1
                shift
                ;;
            -vvv)
                export I2G_MPI_START_VERBOSE=1
                export I2G_MPI_START_DEBUG=1
                export I2G_MPI_START_TRACE=1
                shift
                ;;
            -pre)
                shift
                export I2G_MPI_PRE_RUN_HOOK=$1
                shift
                ;;
            -post)
                shift
                export I2G_MPI_POST_RUN_HOOK=$1
                shift
                ;;
            -pcmd)
                shift
                export I2G_MPI_PRECOMMAND=$1
                shift
                ;;
            -pnode)
                export I2G_MPI_SINGLE_PROCESS=1
                shift
                ;;
            -pcore)
                export I2G_MPI_PER_CORE=1
                shift
                ;;
            -psocket)
                export I2G_MPI_PER_SOCKET=1
                shift
                ;;
            -npnode)
                shift
                export I2G_MPI_PER_NODE=$1
                shift
                ;;
            -np)
                shift
                export I2G_MPI_NP=$1
                shift
                ;;
            -c)
                shift
                export I2G_MPI_CONFIG=$1
                shift
                ;;
            -i)
                shift
                export I2G_MPI_APPLICATION_STDIN=$1
                shift
                ;;
            -o)
                shift
                export I2G_MPI_APPLICATION_STDOUT=$1
                shift
                ;;
            -e)
                shift
                export I2G_MPI_APPLICATION_STDERR=$1
                shift
                ;;
            -x)
                shift
                if [[ $1 == *=* ]] ; then
                    mpi_start_export_variable `echo $1 | cut -f1 -d"="` `echo $1 | cut -f2- -d"="`
                else
                    mpi_start_export_variable $1 
                fi
                shift
                ;;
            -d)
                shift
                eval export $1
                shift
                ;;
            --)
                shift
                break
                ;;
            *)
                if test "${1:0:1}" = "-" ; then
                    echo "Invalid option $1" 1>&2
                    echo 1>&2
                    print_usage
                    exit 1
                fi
                break
                ;;
        esac
    done
    if test "x$1" != "x" ; then
        export I2G_MPI_APPLICATION=$1
        shift
    fi
    if test "x$*" != "x" ; then
        export I2G_MPI_APPLICATION_ARGS="$*"
    fi
    main "$arguments"
fi


